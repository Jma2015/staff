/*
 *  Copyright 2010 Utkin Dmitry
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/*
 *  This file is part of the WSF Staff project.
 *  Please, visit http://code.google.com/p/staff for more information.
 */

// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include <rise/common/ExceptionTemplate.h>
#include <rise/common/Log.h>
#include <staff/common/DataObject.h>
#include <staff/das/common/DataSource.h>
#include <staff/das/common/DataSourceFactory.h>
#include <staff/das/common/ProviderFactory.h>
#include <staff/das/common/ScriptExecuter.h>
#include "DataAccessServiceImpl.h"

namespace staff
{
namespace das
{

  DataAccessServiceImpl::DataAccessServiceImpl():
    m_pDataSource(NULL)
  {
    try
    {
      // initialize datasources and create virtual components and services
      DataSourceFactory::Inst();
    }
    RISE_CATCH_ALL
  }

  DataAccessServiceImpl::~DataAccessServiceImpl()
  {
  }

  StringList DataAccessServiceImpl::GetProviders()
  {
    StringList tResult;
    ProviderFactory::Inst().GetProviders(tResult);
    return tResult;  // result
  }

  StringList DataAccessServiceImpl::GetDataSources()
  {
    StringList lsResult;
    DataSourceFactory::Inst().GetDataSources(lsResult);
    return lsResult;
  }

  void DataAccessServiceImpl::SetDataSource(const std::string& sDataSource)
  {
    m_pDataSource = &DataSourceFactory::Inst().GetDataSource(sDataSource);

    const std::string& sProvider = m_pDataSource->GetProviderName();

    m_tpProvider = ProviderFactory::Inst().Allocate(sProvider);
    RISE_ASSERTS(m_tpProvider.Get() != NULL, "Can't allocate provider [" + sProvider + "]");
    m_tpProvider->Init(*m_pDataSource);
  }

  void DataAccessServiceImpl::FreeDataSource()
  {
    m_pDataSource = NULL;
    m_tpProvider.Release();
  }

  CDataObject& operator<<(CDataObject& rdoTypes, const Type& rType)
  {
    CDataObject tdoType = rdoTypes.CreateChild("Type");

    tdoType.CreateChild("Name").SetText(rType.sName);
    tdoType.CreateChild("Descr").SetText(rType.sDescr);
    tdoType.CreateChild("Extern").SetText(rType.bExtern ? "True" : "False");

    switch (rType.eType)
    {
    case Type::Generic:
    case Type::DataObject:
      {
        tdoType.CreateChild("Type").SetText("generic");
        tdoType.CreateChild("DataType").SetText(rType.sType);
        break;
      }

    case Type::Struct:
      {
        tdoType.CreateChild("Type").SetText("struct");
        CDataObject tdoMembers = tdoType.CreateChild("Members");

        for (TypesList::const_iterator itChildType = rType.lsChilds.begin();
            itChildType != rType.lsChilds.end(); ++itChildType)
        {
          const Type& rChildType = *itChildType;
          if (rChildType.eType != Type::Generic)
          {
            // chagne format
            CDataObject tdoType = tdoMembers.CreateChild("Type");

            tdoType.CreateChild("Name").SetText(rChildType.sName);
            tdoType.CreateChild("Descr").SetText(rChildType.sDescr);
            tdoType.CreateChild("Extern").SetText(rChildType.bExtern ? "True" : "False");
            tdoType.CreateChild("Type").SetText("struct");
            tdoType.CreateChild("DataType").SetText(rChildType.sType);
          }
          else
          {
            tdoMembers << rChildType;
          }
        }

        break;
      }

    case Type::List:
      {
        tdoType.CreateChild("Type").SetText("list");
        tdoType.CreateChild("ItemType").SetText(rType.sType);
        break;
      }

//    case Type::DataObject:
//      {
//        tdoType.CreateChild("Type").SetText("dataobject");
//        break;
//      }

    default:
      {
        rise::LogWarning() << "Can't write type " << rType.eType;
      }
    }

    return rdoTypes;
  }

  CDataObject& operator<<(CDataObject& rdoOperations, const Operation& rOperation)
  {
    CDataObject tdoOperation = rdoOperations.CreateChild("Operation");

    tdoOperation.CreateChild("Name").SetText(rOperation.sName);
    tdoOperation.CreateChild("Descr").SetText(rOperation.sDescr);

    CDataObject tdoParams = tdoOperation.CreateChild("Params");

    for (TypesList::const_iterator itParam = rOperation.lsParams.begin();
          itParam != rOperation.lsParams.end(); ++itParam)
    {
      const Type& rParam = *itParam;

      CDataObject tdoParam = tdoParams.CreateChild("Param");

      tdoParam.CreateChild("Name").SetText(rParam.sName);
      tdoParam.CreateChild("Type").SetText(rParam.sType);
    }

    std::string sReturnType;

    if (rOperation.stReturn.eType == Type::Void)
    {
      sReturnType = "void";
    }
    else
    {
      if (rOperation.stReturn.eType == Type::List ||
          rOperation.stReturn.eType == Type::Struct)
      {
        sReturnType = rOperation.stReturn.sName;
      }
      else
      {
        sReturnType = rOperation.stReturn.sType;
      }
    }

    tdoOperation.CreateChild("Return").SetText(sReturnType);

    return rdoOperations;
  }

  //  get project!
  CDataObject DataAccessServiceImpl::GetInterface() const
  {
    RISE_ASSERTS(m_pDataSource, "Data Source is not set");

    staff::CDataObject tdoInterface("Interface");
    tdoInterface.CreateChild("Name").SetText(m_pDataSource->GetName());
    tdoInterface.CreateChild("Descr").SetText(m_pDataSource->GetDescr());
    tdoInterface.CreateChild("Namespace").SetText(m_pDataSource->GetNamespace());

    // includes
    staff::CDataObject tdoIncludes = tdoInterface.CreateChild("Includes");
    const IncludesList& rmIncludes = m_pDataSource->GetIncludes();

    for (IncludesList::const_iterator itInclude = rmIncludes.begin();
      itInclude != rmIncludes.end(); ++itInclude)
    {
      staff::CDataObject tdoInclude = tdoIncludes.CreateChild("Include");

      std::string sName = itInclude->sFileName;
      std::string::size_type nPos = sName.find_last_of('.');
      if (nPos != std::string::npos)
      {
        sName.erase(nPos);
      }

      tdoInclude.CreateChild("Name").SetText(sName);
      tdoInclude.CreateChild("FileName").SetText(itInclude->sFileName);
      tdoInclude.CreateChild("Namespace").SetText(m_pDataSource->GetNamespace());

      staff::CDataObject tdoTypes = tdoInclude.CreateChild("Types");

      const TypesList& rlsTypes = itInclude->lsTypes;
      for (TypesList::const_iterator itType = rlsTypes.begin(); itType != rlsTypes.end(); ++itType)
      {
        tdoTypes << *itType;
      }
    }

    // types
    staff::CDataObject tdoTypes = tdoInterface.CreateChild("Types");

    const TypesList& rlsTypes = m_pDataSource->GetTypes();
    for (TypesList::const_iterator itType = rlsTypes.begin(); itType != rlsTypes.end(); ++itType)
    {
      tdoTypes << *itType;
    }

    // operations
    staff::CDataObject tdoOperations = tdoInterface.CreateChild("Operations");

    const OperationsList& rmOperations = m_pDataSource->GetOperations();
    for (OperationsList::const_iterator itOperation = rmOperations .begin();
        itOperation != rmOperations .end(); ++itOperation)
    {
      tdoOperations << *itOperation;
    }

    return tdoInterface;
  }

  CDataObject DataAccessServiceImpl::Invoke(const CDataObject& rdoOperation)
  {
    RISE_ASSERTS(m_tpProvider.Get() != NULL, "Not initialized");

    ScriptExecuter tScriptExecuter(rdoOperation, *m_pDataSource, m_tpProvider);
    return tScriptExecuter.Process();
  }

}
}

