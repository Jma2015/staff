// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include <sstream>
#include <staff/utils/Log.h>
#include <staff/utils/ByteArray.h>
#include <staff/utils/HexBinary.h>
#include <staff/utils/Base64Binary.h>
#include "KeyGeneratorImpl.h"

namespace samples
{
namespace binarydata
{

KeyGeneratorImpl::KeyGeneratorImpl()
{
}

KeyGeneratorImpl::~KeyGeneratorImpl()
{
}

void KeyGeneratorImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void KeyGeneratorImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

staff::hexBinary KeyGeneratorImpl::GenerateHexKey(unsigned uSourceKey)
{
  staff::ByteArray baData;
  GenerateKey(uSourceKey, baData);

  staff::hexBinary tResult(baData);
  staff::LogInfo() << "Generated new hex key: [" << tResult.ToString() << "]";
  return tResult;  // result
}

staff::base64Binary KeyGeneratorImpl::GenerateBase64Key(unsigned uSourceKey)
{
  staff::ByteArray baData;
  GenerateKey(uSourceKey, baData);

  staff::base64Binary tResult(baData);
  staff::LogInfo() << "Generated new base64 key: [" << tResult.ToString() << "]";
  return tResult;  // result
}

bool KeyGeneratorImpl::ValidateHexKey(const staff::hexBinary& rKey)
{
  return ValidateKey(rKey.GetBytes());
}

bool KeyGeneratorImpl::ValidateBase64Key(const staff::base64Binary& rKey)
{
  return ValidateKey(rKey.GetBytes());
}

void KeyGeneratorImpl::GenerateKey(unsigned uSourceKey, staff::ByteArray& rResult)
{
  std::ostringstream tKeyBuffer(std::ios_base::out | std::ios_base::binary);

  // put signature and source key
  tKeyBuffer << m_sSignature << uSourceKey;

  // calculate simple 2 byte checksum
  const std::string& sData = tKeyBuffer.str();
  short shCheckSum = Checksum(sData.data(), sData.size());

  // set checksum
  tKeyBuffer << shCheckSum;

  const std::string& sResultData = tKeyBuffer.str();
  rResult.Set(sResultData.size());
  sResultData.copy(rResult.GetData(), rResult.GetSize());
}

bool KeyGeneratorImpl::ValidateKey(const staff::ByteArray& rKey)
{
  // calculate checksum to check excluding existing checksum
  short shCheckSum = Checksum(rKey.GetData(), rKey.GetSize() - sizeof(short));

  std::istringstream tKeyBuffer(std::string(rKey.GetData(), rKey.GetSize()),
                                std::ios_base::in | std::ios_base::binary);

  std::string sSig;
  unsigned uSourceKey = 0;
  short shExistingCheckSum = 0;

  tKeyBuffer >> sSig >> uSourceKey >> shExistingCheckSum;

  return sSig == m_sSignature && shExistingCheckSum == shCheckSum;
}

short KeyGeneratorImpl::Checksum(const staff::byte* pData, unsigned long ulSize)
{
  short shCheckSum = 0;

  for (; ulSize; --ulSize, ++pData)
  {
    shCheckSum += *pData;
  }
  return shCheckSum;
}

const std::string KeyGeneratorImpl::m_sSignature = "KeySign";

}
}

