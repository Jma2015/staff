<?xml version="1.0" encoding="UTF-8"?>
<!-- This file generated by staff_codegen. -->
<!-- For more information please visit: http://code.google.com/p/staff/ -->
#var ServiceName $(Interface.Classes.Class.Name)
\
#ifneq($($tns),)
#var TargetNamespace $($tns)
#else
#var TargetNamespace http://tempui.org/$(Interface.Classes.Class.ServiceNsName)
#ifeqend
\
#ifneq($(Interface.Classes.Class.ServiceUri),)
#var ServiceUri $(Interface.Classes.Class.ServiceUri)
#else
#ifneq($($serviceuri),)
#var ServiceUri $($serviceuri)
#else
#var ServiceUri http://localhost:9090/axis2/services/$(Interface.Classes.Class.ServiceNsName)
#ifeqend
#ifeqend
\
<wsdl:definitions
    name="$($ServiceName)"
#ifeq($($bpel),true)
    xmlns:plnk="http://docs.oasis-open.org/wsbpel/2.0/plnktype"
#else
\
#ifeqend
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
    xmlns="http://www.w3.org/2001/XMLSchema"
    xmlns:tns="$($TargetNamespace)"
    targetNamespace="$($TargetNamespace)">
  <wsdl:types>
    <schema
        targetNamespace="$($TargetNamespace)"
        xmlns:staff="http://www.w3.org/2001/XMLSchema"
        xmlns:tns="$($TargetNamespace)">

      <!-- service operations -->
#foreach $(Interface.Classes.Class.Members)
      <element name="$(Member.Name)">
#ifneq($(Member.Params.$Count),0)
        <complexType>
          <sequence>
#foreach $(Member.Params)
#ifeq($(Param.DataType.Type),dataobject)
            <element name="$(Param.Name)">
              <complexType>
                <sequence>
                  <any/>
                </sequence>
              </complexType>
            </element>
#else
            <element name="$(Param.Name)" type="\
#ifeq($(Param.DataType.Name),bool)
staff:boolean\
#else
#ifeq($(Param.DataType.Name),float||double||long||int||short)
staff:$(Param.DataType.Name)\
#else
#ifeq($(Param.DataType.Type),string)
staff:string\
#else
#ifeq($(Param.DataType.Type),struct||typedef)
tns:$(Param.DataType.NativeName)\
#else
$(Param.DataType.Name)\
#ifeqend
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
#end
          </sequence>
        </complexType>
#else
        <complexType/>
#ifeqend
      </element>

#var sResponse $(Member.Return.ResponseName)
#var sResult $(Member.Return.NodeName)
#ifneq($($sResult),) // result element name is defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResponse $(Member.Name)Response
#else
\
#ifeqend // ----------  result name is defined  --------------------------
      <element name="$($sResponse)">
        <complexType>
          <sequence>
#ifeq($(Member.Return.Type),dataobject)
            <element name="$($sResult)">
              <complexType>
                <sequence>
                  <any/>
                </sequence>
              </complexType>
            </element>
#else
            <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),bool)
staff:boolean\
#else
#ifeq($(Member.Return.Name),float||double||long||int||short)
staff:$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Type),string)
staff:string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
tns:$(Member.Return.NativeName)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
          </sequence>
        </complexType>
      </element>

#else //  result element name is not defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResult $(Member.Name)Result
#else
#var sResult $($sResponse)
#ifeqend // ----------  result name is not defined  --------------------------
#ifeq($(Member.Return.Name),void)
      <element name="$($sResult)">
        <complexType/>
      </element>
#else
#ifeq($(Member.Return.Type),dataobject)
      <element name="$($sResult)">
        <complexType>
          <sequence>
            <any/>
          </sequence>
        </complexType>
      </element>
#else
      <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),bool)
staff:boolean\
#else
#ifeq($(Member.Return.Name),float||double||long||int||short)
staff:$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Type),string)
staff:string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
tns:$(Member.Return.NativeName)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
#ifeqend
#ifeqend // #ifneq($($sResult),) // result element name is defined

#end // #foreach $(Interface.Classes.Class.Members)
#ifneq($(Interface.Structs.$Count),0)

    <!-- structures -->
#foreach $(Interface.Structs)
#ifeq($(Struct.Extern),0) // do not serialize extern type

    <complexType name="$(Struct.NativeName)">
#ifneq($(Struct.Description),)
      <documentation>$(Struct.Description)</documentation>
#else
\
#ifeqend
#ifneq($(Struct.Parent),)       // inherited
#var sIndent   
      <complexContent mixed="false">
#ifneq($(Struct.Members.$Count),0)
        <extension base="tns:$(Struct.NativeName)">
#else
        <extension base="tns:$(Struct.NativeName)"/>
#ifeqend
#else                          // not inherited
#var sIndent 
\
#ifeqend 
#ifneq($(Struct.Members.$Count),0)
$($sIndent)      <sequence>
#foreach $(Struct.Members)
#ifeq($(Param.DataType.Type),dataobject)
$($sIndent)        <element name="$(Param.Name)">
$($sIndent)          <complexType>
#ifneq($(Param.Description),)
$($sIndent)            <documentation>$(Param.Description)</documentation>
#else
\
#ifeqend
$($sIndent)            <sequence>
$($sIndent)              <any/>
$($sIndent)            </sequence>
$($sIndent)          </complexType>
$($sIndent)        </element>
#else
$($sIndent)        <element name="$(Param.Name)" type="\
#ifeq($(Param.DataType.Name),bool)
staff:boolean\
#else
#ifeq($(Param.DataType.Name),float||double||long||int||short)
staff:$(Param.DataType.Name)\
#else
#ifeq($(Param.DataType.Type),string)
staff:string\
#else
#ifeq($(Param.DataType.Type),struct||typedef)
tns:$(Param.DataType.NativeName)\
#else
#ifeq($(Param.DataType.Type),template)
staff:$(Param.DataType.TemplateParams.TemplateParam1.Name)" maxOccurs="unbounded\
#else
$(Param.DataType.Name)\
#ifeqend
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend  // element
#ifneq($(Param.Description),)
">
$($sIndent)          <documentation>$(Param.Description)</documentation>
$($sIndent)        </element>
#else
"/>
#ifeqend
#ifeqend
#end // #foreach $(Struct.Members)
$($sIndent)      </sequence>
#else
\
#ifeqend // $(Struct.Members.$Count),0
#ifneq($(Struct.Parent),)
#ifneq($(Struct.Members.$Count),0)
        </extension>
#else
\
#ifeqend
      </complexContent>
#else
\
#ifeqend
    </complexType>
#else
\
#ifeqend //#ifeq($(Struct.Extern),0) // do not serialize extern type
#end // #foreach $(Interface.Structs)
#else
\
#ifeqend // #ifneq($(Interface.Structs.$Count),0)
#ifneq($(Interface.Typedefs.$Count),0)

    <!-- typedefs -->
#foreach $(Interface.Typedefs)
#ifeq($(Typedef.Extern),0) // do not serialize extern type
#ifeq($(Typedef.DataType.IsTemplate),1)
    <complexType name="$(Typedef.NativeName)">
#ifneq($(Typedef.Description),)
      <documentation>$(Typedef.Description)</documentation>
#else
\
#ifeqend
      <sequence>
#ifeq($(Typedef.DataType.Name),staff::Array||std::list||std::vector)  # -- list ------------------
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),dataobject)
        <element minOccurs="0" maxOccurs="unbounded" name="Item">
          <complexType>
            <sequence>
              <any/>
            </sequence>
          </complexType>
        </element>
#else
        <element minOccurs="0" maxOccurs="unbounded" name="Item" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),bool)
staff:boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),float||double||long||int||short)
staff:$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),string)
staff:string\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),struct||typedef)
tns:$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
" nillable="true" />
#ifeqend
#else
#ifeq($(Typedef.DataType.Name),std::map||std::multimap) # -- map -------------------------
        <element minOccurs="0" maxOccurs="unbounded" name="Item" nillable="true">
          <complexType>
            <sequence>
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),dataobject)
              <element name="Key">
                <complexType>
                  <sequence>
                    <any/>
                  </sequence>
                </complexType>
              </element>
#else
              <element name="Key" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),bool)
staff:boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),float||double||long||int||short)
staff:$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),string)
staff:string\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),struct||typedef)
tns:$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
" />
#ifeqend
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Type),dataobject)
              <element name="Value">
                <complexType>
                  <sequence>
                    <any/>
                  </sequence>
                </complexType>
              </element>
#else
              <element name="Value" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Name),bool)
staff:boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Name),float||double||long||int||short)
staff:$(Typedef.DataType.TemplateParams.TemplateParam2.NativeName)\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Type),string)
staff:string\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Type),struct||typedef)
tns:$(Typedef.DataType.TemplateParams.TemplateParam2.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam2.NativeName)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
" />
#ifeqend
            </sequence>
          </complexType>
        </element>
#else
#cgerror "Cannot generate type $(Typedef.DataType.Name)"
#ifeqend
#ifeqend
      </sequence>
    </complexType>
#else
    <simpleType name="$(Typedef.NativeName)">
#ifeq($(Typedef.DataType.Type),dataobject)
      <complexType>
        <sequence>
          <any/>
        </sequence>
      </complexType>
#else
      <restriction base="\
#ifeq($(Typedef.DataType.Name),bool)
staff:boolean\
#else
#ifeq($(Typedef.DataType.Name),float||double||long||int||short)
staff:$(Typedef.DataType.Name)\
#else
#ifeq($(Typedef.DataType.Type),string)
staff:string\
#else
#ifeq($(Typedef.DataType.Type),struct||typedef)
tns:$(Typedef.DataType.NativeName)\
#else
$(Typedef.DataType.Name)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
    </simpleType>
#ifeqend

#ifeqend // #ifeq($(Typedef.Extern),0) // do not serialize extern type
#end // #foreach $(Interface.Typedefs)
#else
\
#ifeqend // #ifneq($(Interface.Typedefs.$Count),0)
    </schema>
  </wsdl:types>

  <!-- Messages -->
#foreach $(Interface.Classes.Class.Members)
  <wsdl:message name="$(Member.Name)Request">
    <wsdl:part element="tns:$(Member.Name)" name="$(Member.Name)Request"/>
  </wsdl:message>

  <wsdl:message name="$(Member.Name)Response">
#ifeq($(Member.Return.ResponseName),) // response is not defined, generating
#var sResponse $(Member.Name)Result
#else
#var sResponse $(Member.Return.ResponseName)
#ifeqend
    <wsdl:part element="tns:$($sResponse)" name="$($sResponse)"/>
  </wsdl:message>

#end // #foreach $(Interface.Classes.Class.Members)
\
  <!-- Port Type -->
  <wsdl:portType name="$($ServiceName)PortType">
#foreach $(Interface.Classes.Class.Members)
    <wsdl:operation name="$(Member.Name)">
#ifneq($(Member.Description),)
      <wsdl:documentation>$(Member.Description)</wsdl:documentation> 
#else
\
#ifeqend
      <wsdl:input message="tns:$(Member.Name)Request" name="$(Member.Name)Request"/>
      <wsdl:output message="tns:$(Member.Name)Response" name="$(Member.Name)Response"/>
    </wsdl:operation>
#end // #foreach $(Interface.Classes.Class.Members)
  </wsdl:portType>

  <!-- binding -->
  <wsdl:binding name="$($ServiceName)SoapBinding" type="tns:$($ServiceName)PortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
#foreach $(Interface.Classes.Class.Members)
    <wsdl:operation name="$(Member.Name)">
      <soap:operation soapAction="\
#ifneq($(Member.SoapAction),)
$(Member.SoapAction)\
#else
$(Interface.Classes.Class.ServiceName)#$(Member.Name)\
#ifeqend
"/>
        <wsdl:input name="$(Member.Name)Request">
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output name="$(Member.Name)Response">
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
#end // #foreach $(Interface.Classes.Class.Members)
  </wsdl:binding>

  <!-- service -->
  <wsdl:service name="$($ServiceName)">
#ifneq($(Interface.Classes.Class.Description),)
    <wsdl:documentation>$(Interface.Classes.Class.Description)</wsdl:documentation>
#else
\
#ifeqend
    <wsdl:port binding="tns:$($ServiceName)SoapBinding" name="$($ServiceName)SoapPort">
      <soap:address location="$($ServiceUri)"/>
    </wsdl:port>
  </wsdl:service>

#ifeq($($bpel),true)
  <!-- bpel partner link -->
  <plnk:partnerLinkType name="$($ServiceName)">
    <plnk:role name="$($ServiceName)Provider" portType="tns:$($ServiceName)PortType"/>
  </plnk:partnerLinkType>
#else
\
#ifeqend
</wsdl:definitions>

