<?xml version="1.0" encoding="UTF-8"?>
<!-- This file generated by staff_codegen. -->
<!-- For more information please visit: http://code.google.com/p/staff/ -->
#var ServiceName $(Interface.Classes.Class.ServiceName)
#var TargetNamespace http://tempui.org/$($ServiceName)
#ifneq($(Interface.Classes.Class.ServiceUri),)
#var ServiceUri $(Interface.Classes.Class.ServiceUri)
#else
#var ServiceUri http://localhost:9090/axis2/services/$(Interface.Classes.Class.ServiceNamespace)$($ServiceName)
#ifeqend
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:tns="$($TargetNamespace)" targetNamespace="$($TargetNamespace)">
  <wsdl:types>
    <schema targetNamespace="$($TargetNamespace)" xmlns:staff="http://www.w3.org/2001/XMLSchema" xmlns:tns="$($TargetNamespace)">

      <!-- service operations -->
#foreach $(Interface.Classes.Class.Members)
      <element name="$(Member.Name)">
#ifneq($(Member.Params.$Count),0)
        <complexType>
          <sequence>
#foreach $(Member.Params)
#ifeq($(Param.DataType.Name),staff::CDataObject)
            <any name="$(Param.Name)" />
#else
            <element name="$(Param.Name)" type="\
#ifeq($(Param.DataType.Name),float||double||long||int||short||bool)
staff:$(Param.DataType.Name)\
#else
#ifeq($(Param.DataType.Name),std::string||rise::CString)
staff:string\
#else
#ifeq($(Param.DataType.Type),struct||typedef)
staff:$(Param.DataType.NativeName)\
#else
$(Param.DataType.Name)\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
#end
          </sequence>
        </complexType>
#else
        <complexType/>
#ifeqend
      </element>

#var sResponse $(Member.Return.ResponseName)
#var sResult $(Member.Return.NodeName)
#ifneq($($sResult),) // result element name is defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResponse $(Member.Name)Response
#else
\
#ifeqend // ----------  result name is defined  --------------------------
      <element name="$($sResponse)">
        <complexType>
          <sequence>
#ifeq($(Member.Return.Name),staff::CDataObject)
            <any name="$($sResult)" />
#else
            <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),float||double||long||int||short||bool)
staff:$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Name),std::string||rise::CString)
staff:string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
staff:$(Member.Return.NativeName)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
"/>
#ifeqend
          </sequence>
        </complexType>
      </element>

#else //  result element name is not defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResult $(Member.Name)Result
#else
#var sResult $($sResponse)
#ifeqend // ----------  result name is not defined  --------------------------
#ifeq($(Member.Return.Name),void)
      <element name="$($sResult)">
        <complexType/>
      </element>
#else
#ifeq($(Member.Return.Name),staff::CDataObject)
      <element name="$($sResult)">
        <complexType>
          <sequence>
            <any />
          </sequence>
        </complexType>
      </element>
#else
      <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),float||double||long||int||short||bool)
staff:$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Name),std::string||rise::CString)
staff:string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
staff:$(Member.Return.NativeName)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
"/>
#ifeqend
#ifeqend
#ifeqend // #ifneq($($sResult),) // result element name is defined

#end // #foreach $(Interface.Classes.Class.Members)
#ifneq($(Interface.Structs.$Count),0)

    <!-- complex types -->
#foreach $(Interface.Structs)

    <complexType name="$(Struct.NativeName)">
#ifneq($(Struct.Parent),)
#var sIdent   
      <complexContent mixed="false">
#ifneq($(Struct.Members.$Count),0)
        <extension base="staff:$(Struct.NativeName)">
#else
        <extension base="staff:$(Struct.NativeName)"/>
#ifeqend
#else
#var sIdent 
\
#ifeqend 
#ifneq($(Struct.Members.$Count),0)
$($sIdent)      <sequence>
#foreach $(Struct.Members)
$($sIdent)        <element name="$(Param.Name)" type="\
#ifeq($(Param.DataType.Name),float||double||long||int||short||bool)
staff:$(Param.DataType.Name)\
#else
#ifeq($(Param.DataType.Name),std::string||rise::CString)
staff:string\
#else
#ifeq($(Param.DataType.Type),struct||typedef)
staff:$(Param.DataType.NativeName)\
#else
#ifeq($(Param.DataType.Type),template)
staff:$(Param.DataType.TemplateParams.TemplateParam1.Name)" maxOccurs="unbounded\
#else
$(Param.DataType.Name)\
#ifeqend
#ifeqend
\
#ifeqend
#ifeqend
"/>
#end // #foreach $(Struct.Members)
$($sIdent)      </sequence>
#else
\
#ifeqend // $(Struct.Members.$Count),0
#ifneq($(Struct.Parent),)
#ifneq($(Struct.Members.$Count),0)
        </extension>
#else
\
#ifeqend
      </complexContent>
#else
\
#ifeqend
    </complexType>
#end // #foreach $(Interface.Structs)
#else
\
#ifeqend // #ifneq($(Interface.Structs.$Count),0)
#ifneq($(Interface.Typedefs.$Count),0)

    <!-- simple types -->
#foreach $(Interface.Typedefs)
#ifeq($(Typedef.DataType.Name),staff::Array||std::list||std::vector)
    <complexType name="$(Typedef.NativeName)">
      <sequence>
        <element minOccurs="0" maxOccurs="unbounded" name="Item" type="staff:$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)" nillable="true" />
      </sequence>
    </complexType>
#else
    <simpleType name="$(Typedef.NativeName)">
      <restriction base="\
#ifeq($(Typedef.DataType.Name),float||double||long||int||short||bool)
staff:$(Typedef.DataType.Name)\
#else
#ifeq($(Typedef.DataType.Name),std::string||rise::CString)
staff:string\
#else
#ifeq($(Typedef.DataType.Type),struct||typedef)
staff:$(Typedef.DataType.NativeName)\
#else
$(Typedef.DataType.Name)\
#ifeqend
\
#ifeqend
#ifeqend
"/>
    </simpleType>
#ifeqend

#end // #foreach $(Interface.Typedefs)
#else
\
#ifeqend // #ifneq($(Interface.Typedefs.$Count),0)
    </schema>
  </wsdl:types>

  <!-- Messages -->
#foreach $(Interface.Classes.Class.Members)
  <wsdl:message name="$(Member.Name)Request">
    <wsdl:part element="tns:$(Member.Name)" name="$(Member.Name)Request"/>
  </wsdl:message>

  <wsdl:message name="$(Member.Name)Response">
#ifeq($(Member.Return.ResponseName),) // response is not defined, generating
#var sResponse $(Member.Name)Result
#else
#var sResponse $(Member.Return.ResponseName)
#ifeqend
    <wsdl:part element="tns:$($sResponse)" name="$($sResponse)"/>
  </wsdl:message>

#end // #foreach $(Interface.Classes.Class.Members)
\
  <!-- Port Type -->
  <wsdl:portType name="$($ServiceName)PortType">
#foreach $(Interface.Classes.Class.Members)
    <wsdl:operation name="$(Member.Name)">
#ifneq($(Member.Description),)
      <wsdl:documentation>$(Member.Description)</wsdl:documentation> 
#else
\
#ifeqend
      <wsdl:input message="tns:$(Member.Name)Request" name="$(Member.Name)Request"/>
      <wsdl:output message="tns:$(Member.Name)Response" name="$(Member.Name)Response"/>
    </wsdl:operation>
#end // #foreach $(Interface.Classes.Class.Members)
  </wsdl:portType>

  <!-- binding -->
  <wsdl:binding name="$($ServiceName)SoapBinding" type="tns:$($ServiceName)PortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
#foreach $(Interface.Classes.Class.Members)
    <wsdl:operation name="$(Member.Name)">
      <soap:operation soapAction="\
#ifneq($(Member.SoapAction),)
$(Member.SoapAction)\
#else
$($ServiceName)#$(Member.Name)\
#ifeqend
"/>
        <wsdl:input name="$(Member.Name)Request">
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output name="$(Member.Name)Response">
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
#end // #foreach $(Interface.Classes.Class.Members)
  </wsdl:binding>

  <!-- service -->
  <wsdl:service name="$($ServiceName)">
#ifneq($(Interface.Classes.Class.Description),)
    <wsdl:documentation>$(Interface.Classes.Class.Description)</wsdl:documentation>
#else
\
#ifeqend
    <wsdl:port binding="tns:$($ServiceName)SoapBinding" name="$($ServiceName)SoapPort">
      <soap:address location="$($ServiceUri)"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions> 
