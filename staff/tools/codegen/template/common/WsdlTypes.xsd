#ifneq($(Interface.Structs.$Count),0)

      <!-- structures -->
#foreach $(Interface.Structs)
#cginclude <common/WsdlStruct.xsd>
#end // #foreach $(Interface.Structs)
#ifeqend // #ifneq($(Interface.Structs.$Count),0)
#ifneq($(Interface.Typedefs.$Count),0)

      <!-- typedefs -->
#foreach $(Interface.Typedefs)
#ifeq($(Typedef.Extern),0) // do not serialize extern type
#ifeq($(Typedef.DataType.IsTemplate),1)
      <complexType name="$(Typedef.NativeName)">
#ifneq($(Typedef.Description),)
        <annotation><documentation>$(Typedef.Description)</documentation></annotation>
#ifeqend
        <sequence>
#ifeq($(Typedef.DataType.NsName),staff::Array||std::list||std::vector)  // -- list ------------------
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),dataobject)
          <element minOccurs="0" maxOccurs="unbounded" name="Item">
            <complexType>
              <sequence>
                <any/>
              </sequence>
            </complexType>
          </element>
#else
          <element minOccurs="0" maxOccurs="unbounded" name="Item" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),bool)
boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),struct||typedef)
tns_$(Typedef.DataType.TemplateParams.TemplateParam1.Namespace.!mangle.!trim/_/):$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#ifeqend
#ifeqend
" nillable="true" />
#ifeqend
#else // bool
#ifeq($(Typedef.DataType.NsName),std::map||std::multimap) // -- map -------------------------
          <element minOccurs="0" maxOccurs="unbounded" name="Item" nillable="true">
            <complexType>
              <sequence>
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),dataobject)
                <element name="Key">
                  <complexType>
                    <sequence>
                      <any/>
                    </sequence>
                  </complexType>
                </element>
#else
                <element name="Key" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Name),bool)
boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam1.Type),struct||typedef)
tns_$(Typedef.DataType.TemplateParams.TemplateParam1.Namespace.!mangle.!trim/_/):$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam1.NativeName)\
#ifeqend
#ifeqend
" />
#ifeqend
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Type),dataobject)
                <element name="Value">
                  <complexType>
                    <sequence>
                      <any/>
                    </sequence>
                  </complexType>
                </element>
#else
                <element name="Value" type="\
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Name),bool)
boolean\
#else
#ifeq($(Typedef.DataType.TemplateParams.TemplateParam2.Type),struct||typedef)
tns_$(Typedef.DataType.TemplateParams.TemplateParam2.Namespace.!mangle.!trim/_/):$(Typedef.DataType.TemplateParams.TemplateParam2.NativeName)\
#else
$(Typedef.DataType.TemplateParams.TemplateParam2.NativeName)\
#ifeqend
#ifeqend
" />
#ifeqend
              </sequence>
            </complexType>
          </element>
#else
#cgerror "Cannot generate type $(Typedef.DataType.Name): [$(Typedef.NsName) $(Typedef.DataType);]"
#ifeqend
#ifeqend
        </sequence>
      </complexType>
#else
      <simpleType name="$(Typedef.NativeName)">
#ifeq($(Typedef.DataType.Type),dataobject)
        <complexType>
          <sequence>
            <any/>
          </sequence>
        </complexType>
#else
        <restriction base="\
#ifeq($(Typedef.DataType.Name),bool)
boolean\
#else
#ifeq($(Typedef.DataType.Type),struct||typedef)
tns_$(Typedef.DataType.Namespace.!mangle.!trim/_/):$(Typedef.DataType.NativeName)\
#else
$(Typedef.DataType.Name)\
#ifeqend
#ifeqend
"/>
#ifeqend
      </simpleType>
#ifeqend

#ifeqend // #ifeq($(Typedef.Extern),0) // do not serialize extern type
#end // #foreach $(Interface.Typedefs)
#ifeqend // #ifneq($(Interface.Typedefs.$Count),0)

