<?xml version="1.0" encoding="UTF-8"?>
<!-- This file generated by staff_codegen. -->
<!-- For more information please visit: http://code.google.com/p/staff/ -->
\
#ifneq($($tns),)
#var TargetNamespace $($tns)
#else
#var TargetNamespace http://tempui.org/$(Interface.Classes.Class.ServiceNsName)
#ifeqend
\
#ifneq($(Interface.Classes.Class.Options.*serviceUri),)
#var ServiceUri $(Interface.Classes.Class.Options.*serviceUri)
#else
#ifneq($($serviceuri),)
#var ServiceUri $($serviceuri)
#else
#var ServiceUri http://localhost:9090/axis2/services/$(Interface.Classes.Class.ServiceNsName)
#ifeqend
#ifeqend
\
<wsdl:definitions
    name="$(Interface.Classes.Class.ServiceName)"
#ifeq($($bpel),true)
    xmlns:plnk="http://docs.oasis-open.org/wsbpel/2.0/plnktype"
#else
\
#ifeqend
    xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
    xmlns="http://www.w3.org/2001/XMLSchema"
#foreach $(Interface.Classes)
    xmlns:tns_$(Class.ServiceNamespace.!mangledot.!trim/_/)="http://tempui.org/$(Class.ServiceNsName)"
#end
#foreach $(Interface.Includes)
    xmlns:tns_$(Include.NsName.!mangledot.!trim/_/)="http://tempui.org/$(Include.NsName)"
#end
    targetNamespace="$($TargetNamespace)">
  <wsdl:types>
    <schema
        targetNamespace="$($TargetNamespace)"
#foreach $(Interface.Classes)
        xmlns:tns_$(Class.ServiceNamespace.!mangledot.!trim/_/)="http://tempui.org/$(Class.ServiceNsName)"\
#end
>
#ifneq($(Interface.Includes.$Count),0)

      <!-- imports -->
#foreach $(Interface.Includes)
      <import namespace="\
#ifneq($(Include.TargetNamespace),)
$(Include.TargetNamespace)\
#else
http://tempui.org/$(Include.NsName)\
#ifeqend
" schemaLocation="$(Include.NsName).xsd" />
#end
#ifeqend

      <!-- service operations -->
#foreach $(Interface.Classes.Class.Members)
      <element name="$(Member.Name)">
#ifneq($(Member.Params.$Count),0)
        <complexType>
          <sequence>
#foreach $(Member.Params)
#ifeq($(Param.DataType.Type),dataobject)
            <element name="$(Param.Name)">
              <complexType>
                <sequence>
                  <any/>
                </sequence>
              </complexType>
            </element>
#else
            <element name="$(Param.Name)" type="\
#ifeq($(Param.DataType.Name),bool)
boolean\
#else
#ifeq($(Param.DataType.Name),float||double||long||int||short)
$(Param.DataType.Name)\
#else
#ifeq($(Param.DataType.Type),string)
string\
#else
#ifeq($(Param.DataType.Type),struct||typedef)
tns_$(Param.DataType.Namespace.!trim/:/.!mangle):$(Param.DataType.NativeName.!dot)\
#else
$(Param.DataType.Name)\
#ifeqend
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
#end
          </sequence>
        </complexType>
#else
        <complexType/>
#ifeqend
      </element>

#var sResponse $(Member.Return.ResponseName)
#var sResult $(Member.Return.NodeName)
#ifneq($($sResult),) // result element name is defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResponse $(Member.Name)Response
#else
\
#ifeqend // ----------  result name is defined  --------------------------
      <element name="$($sResponse)">
        <complexType>
          <sequence>
#ifeq($(Member.Return.Type),dataobject)
            <element name="$($sResult)">
              <complexType>
                <sequence>
                  <any/>
                </sequence>
              </complexType>
            </element>
#else
            <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),bool)
boolean\
#else
#ifeq($(Member.Return.Name),float||double||long||int||short)
$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Type),string)
string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
#ifneq($(Member.Return.Namespace),)
tns_$(Member.Return.Namespace.!trim/:/.!mangle)\
#else
tns_$(Class.ServiceNamespace.!mangledot.!trim/_/)\
#ifeqend
:$(Member.Return.NativeName.!dot)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
          </sequence>
        </complexType>
      </element>

#else //  result element name is not defined
#ifeq($($sResponse),) // response is not defined, generating
#var sResult $(Member.Name)Result
#else
#var sResult $($sResponse)
#ifeqend // ----------  result name is not defined  --------------------------
#ifeq($(Member.Return.Name),void)
      <element name="$($sResult)">
        <complexType/>
      </element>
#else
#ifeq($(Member.Return.Type),dataobject)
      <element name="$($sResult)">
        <complexType>
          <sequence>
            <any/>
          </sequence>
        </complexType>
      </element>
#else
      <element name="$($sResult)" type="\
#ifeq($(Member.Return.Name),bool)
boolean\
#else
#ifeq($(Member.Return.Name),float||double||long||int||short)
$(Member.Return.Name)\
#else
#ifeq($(Member.Return.Type),string)
string\
#else
#ifeq($(Member.Return.Type),struct||typedef)
#ifneq($(Member.Return.Namespace),)
tns_$(Member.Return.Namespace.!trim/:/.!mangle)\
#else
tns_$(Class.ServiceNamespace.!mangledot.!trim/_/)\
#ifeqend
:$(Member.Return.NativeName.!dot)\
#else
$(Member.Return.Name)\
#ifeqend
\
#ifeqend
#ifeqend
#ifeqend
"/>
#ifeqend
#ifeqend
#ifeqend // #ifneq($($sResult),) // result element name is defined

#end // #foreach $(Interface.Classes.Class.Members)
#cginclude <common/WsdlTypes.xsd>
    </schema>
  </wsdl:types>

  <!-- Messages -->
#foreach $(Interface.Classes.Class.Members)
  <wsdl:message name="$(Member.Name)Request">
    <wsdl:part element="tns_$(Class.ServiceNamespace.!mangledot.!trim/_/):$(Member.Name)" name="$(Member.Name)Request"/>
  </wsdl:message>

  <wsdl:message name="$(Member.Name)Response">
#ifeq($(Member.Return.ResponseName),) // response is not defined, generating
#var sResponse $(Member.Name)Result
#else
#var sResponse $(Member.Return.ResponseName)
#ifeqend
    <wsdl:part element="tns_$(Class.ServiceNamespace.!mangledot.!trim/_/):$($sResponse)" name="$($sResponse)"/>
  </wsdl:message>

#end // #foreach $(Interface.Classes.Class.Members)
\
  <!-- Port Type -->
#foreach $(Interface.Classes)
  <wsdl:portType name="$(Class.ServiceName)PortType">
#foreach $(Class.Members)
    <wsdl:operation name="$(Member.Name)">
#ifneq($(Member.Description),)
      <wsdl:documentation>$(Member.Description)</wsdl:documentation> 
#else
\
#ifeqend
#var TnsPrefix tns_$(Class.ServiceNamespace.!mangledot.!trim/_/)
      <wsdl:input message="$($TnsPrefix):$(Member.Name)Request" name="$(Member.Name)Request"/>
      <wsdl:output message="$($TnsPrefix):$(Member.Name)Response" name="$(Member.Name)Response"/>
    </wsdl:operation>
#end // #foreach $(Class.Members)
  </wsdl:portType>
#end // #foreach $(Interface.Classes)

  <!-- binding -->
#foreach $(Interface.Classes)
  <wsdl:binding name="$(Class.ServiceName)SoapBinding" type="tns_$(Class.ServiceNamespace.!mangledot.!trim/_/):$(Class.ServiceName)PortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
#foreach $(Class.Members)
    <wsdl:operation name="$(Member.Name)">
      <soap:operation soapAction="$(Member.Options.*soapAction)"/>
      <wsdl:input name="$(Member.Name)Request">
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output name="$(Member.Name)Response">
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
#end // #foreach $(Class.Members)
  </wsdl:binding>
#end // #foreach $(Interface.Classes)

  <!-- service -->
#foreach $(Interface.Classes)
  <wsdl:service name="$(Class.ServiceName)">
#ifneq($(Interface.Classes.Class.Description),)
    <wsdl:documentation>$(Interface.Classes.Class.Description)</wsdl:documentation>
#else
\
#ifeqend
    <wsdl:port binding="tns_$(Class.ServiceNamespace.!mangledot.!trim/_/):$(Class.ServiceName)SoapBinding" name="$(Class.ServiceName)SoapPort">
      <soap:address location="$($ServiceUri)"/>
    </wsdl:port>
  </wsdl:service>
#end // #foreach $(Interface.Classes)

#ifeq($($bpel),true)
#foreach $(Interface.Classes)
  <!-- bpel partner link -->
  <plnk:partnerLinkType name="$(Class.ServiceName)">
    <plnk:role name="$(Class.ServiceName)Provider" portType="tns_$(Class.ServiceNamespace.!mangledot.!trim/_/):$(Class.ServiceName)PortType"/>
  </plnk:partnerLinkType>
#end // #foreach $(Interface.Classes)
#else
\
#ifeqend
</wsdl:definitions>

