// This file generated by staff_codegen
// For more information please visit: http://code.google.com/p/staff/
// Service Implementation

#include <staff/utils/Log.h>
#include <staff/utils/ByteArray.h>
#include <staff/utils/HexBinary.h>
#include <staff/utils/Base64Binary.h>
#include <staff/utils/tostring.h>
#include <staff/common/Exception.h>
#include "KeyGeneratorImpl.h"

namespace samples
{
namespace binarydata
{

std::string& operator<<(std::string& rString, const std::string& sData)
{
  return rString.append(sData).append(1, '\0');
}

std::string& operator>>(std::string& rString, std::string& sData)
{
  sData.erase();
  std::string::size_type nPos = rString.find('\0');
  if (nPos != std::string::npos)
  {
    sData = rString.substr(0, nPos);
    rString.erase(0, sData.size() + 1);
  }
  return rString;
}

template <typename Type>
std::string& operator<<(std::string& rString, Type tType)
{
  return rString.append(reinterpret_cast<const char*>(&tType), sizeof(Type));
}

template <typename Type>
std::string& operator>>(std::string& rString, Type& tType)
{
  rString.copy(reinterpret_cast<char*>(&tType), sizeof(Type));
  rString.erase(0, sizeof(Type));
  return rString;
}

KeyGeneratorImpl::KeyGeneratorImpl()
{
}

KeyGeneratorImpl::~KeyGeneratorImpl()
{
}

void KeyGeneratorImpl::OnCreate()
{
  // this function is called when service instance is created and registered
}

void KeyGeneratorImpl::OnDestroy()
{
  // this function is called immediately before service instance destruction
}

staff::hexBinary KeyGeneratorImpl::GenerateHexKey(unsigned uSourceKey)
{
  staff::ByteArray baData;
  GenerateKey(uSourceKey, baData);

  staff::hexBinary tResult(baData);
  staff::LogInfo() << "Generated new hex key: [" << tResult.ToString() << "]";
  return tResult;  // result
}

staff::base64Binary KeyGeneratorImpl::GenerateBase64Key(unsigned uSourceKey)
{
  staff::ByteArray baData;
  GenerateKey(uSourceKey, baData);

  staff::base64Binary tResult(baData);
  staff::LogInfo() << "Generated new base64 key: [" << tResult.ToString() << "]";
  return tResult;  // result
}

bool KeyGeneratorImpl::ValidateHexKey(const staff::hexBinary& rKey)
{
  return ValidateKey(rKey.GetBytes());
}

bool KeyGeneratorImpl::ValidateBase64Key(const staff::base64Binary& rKey)
{
  return ValidateKey(rKey.GetBytes());
}

void KeyGeneratorImpl::GenerateKey(unsigned uSourceKey, staff::ByteArray& rResult)
{
  std::string sKeyBuffer;

  // put signature and source key
  sKeyBuffer << m_sSignature << uSourceKey;

  // calculate simple 2 byte checksum
  short shCheckSum = Checksum(sKeyBuffer);

  // set checksum
  sKeyBuffer << shCheckSum;

  rResult.Set(sKeyBuffer.size());
  sKeyBuffer.copy(rResult.GetData(), rResult.GetSize());
}

bool KeyGeneratorImpl::ValidateKey(const staff::ByteArray& rKey)
{
  STAFF_ASSERT(rKey.GetSize() >= sizeof(short), "Invalid data size: " +
               staff::ToString(rKey.GetSize()));

  // calculate checksum to check excluding existing checksum
  short shCheckSum = Checksum(std::string(rKey.GetData(), rKey.GetSize() - sizeof(short)));

  std::string sKeyBuffer(rKey.GetData(), rKey.GetSize());

  std::string sSig;
  unsigned uSourceKey = 0;
  short shExistingCheckSum = 0;

  sKeyBuffer >> sSig >> uSourceKey >> shExistingCheckSum;

  return sSig == m_sSignature && shExistingCheckSum == shCheckSum;
}

short KeyGeneratorImpl::Checksum(const std::string& sBuffer)
{
  const char* pBuffer = reinterpret_cast<const char*>(sBuffer.data());
  short shCheckSum = 0;

  for (std::string::size_type nSize = sBuffer.size(); nSize; --nSize, ++pBuffer)
  {
    shCheckSum += *pBuffer;
  }
  return shCheckSum;
}

const std::string KeyGeneratorImpl::m_sSignature = "KeySign";

}
}

